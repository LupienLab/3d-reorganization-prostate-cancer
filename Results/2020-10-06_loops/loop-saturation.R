# ==============================================================================
# Description
# ==============================================================================
# This will plot a saturation curve from peak files generated by MACS2 or any 
# similar data (BED format).
# The plot has y-axis=number of unique peaks in 1000's; x-axis=number of samples

# Steps:
#   1. On a cohort of samples, the sample order is randomised and the number of
#      peaks/regions identified in the first sample is plotted at x=1
#   2. The peaks identified in the second sample are compared to those found in
#      the first and only those which are new/unique are kept.
#      The sum of these new Sample2-only peaks and the Sample1-peaks is then
#      plotted for x=2
#   3. For every following sample, the number of NEW peaks identified in that
#      sample is added to the cumulative sum of unique peaks identified in all
#      preceding samples and plotted at x=sample number
#   4. Steps 1-3 are repeated n times. n should be defined by the user.
#   5. The final plot displays the cumulative peak number at each sample number
#      averaged over the n iterations, as well as standard error of the mean
#      error bars.
#   6. A self-starting non-linear regression model is fitted to the data and is
#      used to predict at what sample number saturation will be reached and what
#      level of saturation has been reached at the current sample size.

# ==============================================================================
# Environment
# ==============================================================================
suppressMessages(library("logging"))
suppressMessages(library("data.table"))
suppressMessages(library("ggplot2"))

N_ITERS <- 100
MAX_SAMPLES <- 60

# ==============================================================================
# Data
# ==============================================================================
loginfo("Loading data")
# load metadata
metadata <- fread("config.tsv", sep = "\t", header = TRUE)
metadata <- metadata[Include == "Yes", .SD]
SAMPLES <- list(
    "all" = metadata[, SampleID],
    "benign" = metadata[Type == "Benign", SampleID],
    "tumour" = metadata[Type == "Malignant", SampleID]
)

# load loop calls
loops <- fread("Loops/merged-loops.tsv", sep = "\t", header = TRUE)


# ==============================================================================
# Analysis
# ==============================================================================
# create peaks list
loops_per_sample <- lapply(
    SAMPLES$all,
    function(s) {
        loops[SampleID == s, loopID]
    }
)
names(loops_per_sample) <- SAMPLES$all
num_loops <- sapply(
    SAMPLES$all,
    function(s) {
        length(loops_per_sample[[s]])
    },
    USE.NAMES = TRUE
)

# number of samples
numsam = length(SAMPLES$all)
# create the results list
data_iter = matrix(ncol = N_ITERS, nrow = numsam)

for (j in 1:N_ITERS) {
    # randomly order the samples
    sampled_loops <- loops_per_sample[sample(1:numsam)]

    # create cumulative set of loop IDs
    sampled_loop_IDs <- vector("list", length = numsam)
    sampled_loop_IDs[[1]] <- sampled_loops[[1]]
    # find union of loop IDs from the combined set of i samples
    for (i in 2:numsam) {
        sampled_loop_IDs[[i]] <- sort(union(sampled_loop_IDs[[i - 1]], sampled_loops[[i]]))
    }
    # count how many there are in this iteration
    sampled_loop_ID_counts <- lengths(sampled_loop_IDs)

    # store data in saturation curve matrix as the j-th column
    data_iter[, j] <- sampled_loop_ID_counts
}

# Calculate summary statistics
bootstrap_summary <- data.table(
    N_Samples = 1:numsam,
    N_Loops_Mean = rowMeans(data_iter),
    N_Loops_SEM = rowSds(data_iter) / sqrt(N_ITERS)
)

# coerce into a data.table for plotting the bootstrap results themselves
bootstraps <- as.data.table(cbind(1:numsam, data_iter))
colnames(bootstraps) <- c("N_Samples", 1:N_ITERS)
bootstraps_long <- melt(
    bootstraps,
    id.vars = "N_Samples",
    variable.name = "Iteration",
    value.name = "N_Loops"
)
bootstraps_long[, Iteration := as.numeric(Iteration)]

# use self starting model for asymptotic data SSasymp

# it follows the formula: Asym+(R0-Asym)*exp(-exp(lrc)*input)
# input  a numeric vector of values at which to evaluate the model.
# Asym  a numeric parameter representing the upper asymptotic value of the model (as input goes to Inf).
# R0  a numeric parameter representing the response when input is zero. This argument is not in SSasympOrig, in which it is assumed to be zero.
# lrc	a numeric parameter representing the natural logarithm of the rate constant.

nlsfitSS <- nls(
    N_Loops_Mean ~ SSasymp(N_Samples, Asym, R0, lrc),
    data = bootstrap_summary,
    control = list(maxiter = 10000)
)

# predict the future values with increasing numbers of samples
pred <- predict(nlsfitSS, list(N_Samples = seq(1, 200, 1)))

# check that the model is a good fit for the data
#   Residual sum of squares
RSS <- sum(residuals(nlsfitSS)^2)
#   Total sum of squares
TSS <- bootstrap_summary[, sum((N_Loops_Mean - mean(N_Loops_Mean))^2)]
#   R-squared measure (this should be close to 1)
r2 <- 1 - (RSS/TSS)
cat("r-squared (close to 1 is a good fit):\n")
print(r2)


# extract key parameters from the model
Asym_coef = summary(nlsfitSS)$coefficients[1] # number of loops at 100% saturation
R0_coef = summary(nlsfitSS)$coefficients[2]
lrc_coef = summary(nlsfitSS)$coefficients[3]

# current fraction of saturation achieved
total_loops <- bootstrap_summary[N_Samples == numsam, N_Loops_Mean]
cur_sat_frac <- total_loops / Asym_coef

# get model-predicted loop and sample numbers at various levels of saturation
saturation_ests <- data.table(
    Frac_Saturation = c(0.9, 0.95, 0.99)
)
saturation_ests[, N_Loops := Asym_coef * Frac_Saturation]
saturation_ests[, N_Samples := -log((Frac_Saturation - 1) * N_Loops / (R0_coef - Asym_coef)) / exp(lrc_coef) ]


# get model-predicted loop and saturation numbers based on the number samples
model_ests <- data.table(
    N_Samples = 1:100
)
model_ests[, Est_N_Loops := Asym_coef + (R0_coef - Asym_coef) * exp(-exp(lrc_coef) * N_Samples)]
model_ests[, Frac_Saturation := Est_N_Loops / Asym_coef]

# ==============================================================================
# Plots
# ==============================================================================
gg <- (
    ggplot()
    + geom_point(
        data = bootstraps_long,
        mapping = aes(x = N_Samples, y = N_Loops, colour = N_Samples),
        position = position_jitter(width = 0.2, height = 0),
        alpha = 0.1
    )
    + geom_boxplot(
        data = bootstraps_long,
        mapping = aes(x = N_Samples, y = N_Loops, group = N_Samples, fill = N_Samples),
        outlier.shape = NA,
        alpha = 0.5
    )
    # asymptotic curve fit
    + geom_path(
        data = model_ests,
        aes(x = N_Samples, y = Est_N_Loops),
        # size = 2,
        linetype = "dashed"
    )
    # label for model
    + geom_text(
        aes(
            x = saturation_ests[Frac_Saturation >= 0.95, mean(N_Samples)],
            y = 0.9 * Asym_coef,
            label = "Model Fit"
        ),
        vjust = 0,
        hjust = 0.5
    )
    # add asymptotic value
    + geom_hline(
        aes(yintercept = c(Asym_coef, total_loops)),
        linetype = "dashed",
        colour = "#1e90ff"

    )
    # labels for horizontal lines
    + geom_text(
        aes(
            x = c(1, 1),
            y = c(total_loops, Asym_coef),
            label = c(
                paste0("Loops Detected: ", total_loops, " (", 100 * round(cur_sat_frac, 3), "%)"),
                paste("Estimated Number of Loops:", round(Asym_coef))
            )
        ),
        vjust = -1,
        hjust = 0,
        colour = "#1e90ff"
    )
    # add bars for number of samples required to reach saturation
    + geom_vline(
        aes(xintercept = saturation_ests[, round(N_Samples)]),
        linetype = "dashed",
        colour = "#66cdaa"
    )
    # labels for vertical lines
    + geom_text(
        data = saturation_ests,
        aes(
            x = round(N_Samples),
            y = total_loops / 2,
            label = paste0(
                100 * Frac_Saturation, "%: ", round(N_Samples), " samples"
            )
        ),
        vjust = -0.5,
        hjust = 0.5,
        angle = 90,
        colour = "#66cdaa"
    )
    + scale_fill_viridis_c()
    + scale_colour_viridis_c()
    + scale_x_continuous(
        name = "Number of samples",
        limits = c(
            0,
            # estimated number of samples required to reach 99% saturation of loop calls
            saturation_ests[Frac_Saturation == 0.99, round(N_Samples) + 1]
        )
    )
    + scale_y_continuous(
        name = "Number of samples",
        limits = c(0, 1.05 * Asym_coef)
    )
    + guides(fill = FALSE, colour = FALSE)
    + theme_minimal()
)
ggsave("Plots/loop-saturation.png", gg, width = 20, height = 8, units = "cm")
