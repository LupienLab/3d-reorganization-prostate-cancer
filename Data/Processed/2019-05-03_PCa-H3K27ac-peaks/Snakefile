# ==============================================================================
# Configuration
# ==============================================================================
import pandas as pd
import os.path as path
import numpy as np

CONFIG = pd.read_csv("config.tsv", index_col=False, sep="\t")

BAM_DIR = "BAMs"
PEAK_DIR = "Peaks"
CORE_DIR = "COREs"
REPORT_DIR = "Reports"

SAMPLES = ["Pca" + str(i) for i in CONFIG["Sample ID"].tolist()]
CHIPS = CONFIG["ChIP Type"].tolist()
UNIQ_SAMPLES = np.unique(SAMPLES)
UNIQ_CAP_SAMPLES = np.unique(["PCa" + str(i) for i in CONFIG["Sample ID"]])

GENOMES = ["hg38"]
CHR_REGEX = "^chr[0-9]{0,3}[XYM]?\\t"

# ==============================================================================
# Meta Rules
# ==============================================================================
rule all:
    input:
        expand(
            path.join(PEAK_DIR, "{sample}_peaks.filtered.{ext}"),
            sample=UNIQ_SAMPLES,
            ext=["narrowPeak", "bdg"],
        ),
        path.join(PEAK_DIR, "catalogue-peaks.bed"),
        path.join(PEAK_DIR, "correlation.tsv"),
        expand(
            path.join(PEAK_DIR, "{sample}_FE.sorted.filtered.{ext}"),
            sample=UNIQ_SAMPLES,
            ext=["bdg", "bw"],
        ),
        expand(
            path.join(CORE_DIR, "{sample}.cores.{ext}"),
            sample=UNIQ_CAP_SAMPLES,
            ext=["bed", "beddb"],
        ),

# ==============================================================================
# Rules
# ==============================================================================
rule call_peaks:
    input:
        chip = path.join(BAM_DIR, "{sample}_H3K27ac.sorted.dedup.bam"),
        input = path.join(BAM_DIR, "{sample}_input.sorted.dedup.bam"),
    output:
        path.join(PEAK_DIR, "{sample}_peaks.xls"),
        path.join(PEAK_DIR, "{sample}_peaks.narrowPeak"),
        path.join(PEAK_DIR, "{sample}_summits.bed"),
        path.join(PEAK_DIR, "{sample}_treat_pileup.bdg"),
        path.join(PEAK_DIR, "{sample}_control_lambda.bdg"),
    params:
        lambda wildcards:
            " ".join([
                "-g hs",
                "-f BAM",
                "-q 0.005",
                "-B",
                "-n {}".format(path.join(PEAK_DIR, wildcards.sample))
            ])
    shell:
        "macs2 callpeak {params} -t {input.chip} -c {input.input}"

rule filter_blacklist_noncanonical:
    input:
        blacklist = "ENCODE-blacklist.bed",
        peaks = path.join(PEAK_DIR, "{sample}_{type}.sorted.{ext}")
    output:
        path.join(PEAK_DIR, "{sample}_{type}.sorted.filtered.{ext}")
    wildcard_constraints:
        sample = "Pca\d+",
        ext = "(bed|bdg)+",
    params:
        "-v -sorted"
    shell:
        # remove blacklist regions and only keep canonical chromosomes (sorting with LC_COLLATE=C to work with bigWigs)
        "bedtools intersect {params} -a {input.peaks} -b <(LC_COLLATE=C sort -k1,1 -k2,2n {input.blacklist}) | awk '/{CHR_REGEX}/ {{print}}' > {output}"

rule narrowPeak2bedGraph:
    input:
        path.join(PEAK_DIR, "{sample}_peaks.filtered.narrowPeak")
    output:
        path.join(PEAK_DIR, "{sample}_peaks.filtered.bdg")
    shell:
        "awk '{{FS=OFS=\"\\t\"}}{{print $1, $2, $3, $5}}' {input} > {output}"

rule catalogue_peaks:
    input:
        expand(path.join(PEAK_DIR, "{sample}_peaks.filtered.narrowPeak"), sample=UNIQ_SAMPLES)
    output:
        path.join(PEAK_DIR, "catalogue-peaks.bed")
    params:
        names = " ".join(UNIQ_SAMPLES)
    shell:
        "bedtools multiinter -names {params.names} -i {input} | bedtools merge -sorted -i stdin | sort -k1,1 -V -k2,2n > {output}"

rule bdg_to_bigwig:
    input:
        bed = path.join(PEAK_DIR, "{sample}_{type}.bdg"),
        genome = path.join("..", "2019-06-18_PCa-LowC-sequencing", "hg38.sizes.txt"),
    output:
        path.join(PEAK_DIR, "{sample}_{type}.bw")
    shell:
        "bedGraphToBigWig {input.bed} {input.genome} {output}"

rule correlate:
    input:
        expand(path.join(PEAK_DIR, "{sample}_treat_pileup.filtered.bw"), sample=UNIQ_SAMPLES)
    output:
        path.join(PEAK_DIR, "correlation.tsv"),
    run:
        for s in input:
            print(s)
            for t in input:
                print("\t", t)
                shell("c=$(bigWigCorrelate {s} {t}); echo -e \"{s}\\t{t}\\t$c\" >> {output}".format(s=s, t=t, output=output))

rule plot_correlation:
    input:
        script = "plot-correlation.R",
        data = path.join(PEAK_DIR, "correlation.tsv"),
    output:
        path.join(REPORT_DIR, "correlation.png"),
    shell:
        "Rscript {input.script}"

rule calc_fe:
    input:
        chip = path.join(PEAK_DIR, "{sample}_treat_pileup.filtered.bdg"),
        ctrl = path.join(PEAK_DIR, "{sample}_control_lambda.bdg"),
    output:
        path.join(PEAK_DIR, "{sample}_FE.bdg"),
    params:
        "-m FE" # linear fold enrichment
    shell:
        "macs2 bdgcmp {params} -t {input.chip} -c {input.ctrl} -o {output}"

rule sort:
    input:
        "{file}.{ext}",
    output:
        "{file}.sorted.{ext}",
    wildcard_constraints:
        ext = "b(ed|dg)"
    shell:
        "LC_COLLATE=C sort -k1,1 -k2,2n {input} > {output}"

rule clodius_agg_1d_bdg:
    input:
        path.join(PEAK_DIR, "{sample}_FE.sorted.filtered.bdg"),
    output:
        path.join(PEAK_DIR, "{sample}_FE.sorted.filtered.beddb"),
    params:
        "-a hg38"
    shell:
        "clodius aggregate bedfile {params} -o {output} {input}"

rule clodius_agg_1d_core:
    input:
        path.join(CORE_DIR, "{sample}.cores.bed"),
    output:
        path.join(CORE_DIR, "{sample}.cores.beddb"),
    params:
        "-a hg38"
    shell:
        "clodius aggregate bedfile {params} -o {output} {input}"

rule cream:
    input:
        script = "calc-cores.R",
        peaks = path.join(PEAK_DIR, "Pca{sampleid}_peaks.filtered.narrowPeak"),
    output:
        path.join(CORE_DIR, "PCa{sampleid}.cores.bed"),
    shell:
        "Rscript {input.script} {input.peaks} {output}"

